============================= test session starts ==============================
platform linux -- Python 3.9.12, pytest-7.1.3, pluggy-1.0.0
rootdir: /home/patel_zeel/gpax, configfile: pyproject.toml
plugins: typeguard-2.13.3, jaxtyping-0.1.0
collected 11 items

tests/test_kernels.py {'kernel': {'lengthscale': DeviceArray([0.5, 0.5], dtype=float64, weak_type=True), 'variance': DeviceArray(0.7, dtype=float64, weak_type=True)}}
{'kernel': {'lengthscale': DeviceArray([0.5, 0.5], dtype=float64), 'variance': DeviceArray(0.7, dtype=float64, weak_type=True)}}
.{'kernel': {'lengthscale': DeviceArray([0.5, 0.5], dtype=float64, weak_type=True), 'variance': DeviceArray(0.7, dtype=float64, weak_type=True)}}
{'kernel': {'lengthscale': DeviceArray([0.5, 0.5], dtype=float64), 'variance': DeviceArray(0.7, dtype=float64, weak_type=True)}}
.{'kernel': {'lengthscale': DeviceArray([0.5, 0.5], dtype=float64, weak_type=True), 'variance': DeviceArray(0.7, dtype=float64, weak_type=True)}}
{'kernel': {'lengthscale': DeviceArray([0.5, 0.5], dtype=float64), 'variance': DeviceArray(0.7, dtype=float64, weak_type=True)}}
.{'kernel': {'lengthscale': DeviceArray([0.5, 0.5], dtype=float64, weak_type=True), 'variance': DeviceArray(0.7, dtype=float64, weak_type=True)}}
{'kernel': {'lengthscale': DeviceArray([0.5, 0.5], dtype=float64), 'variance': DeviceArray(0.7, dtype=float64, weak_type=True)}}
.{'kernel': {'lengthscale': DeviceArray([1., 1.], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
{'kernel': {'lengthscale': DeviceArray([[1., 1.],
             [1., 1.]], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
F{'kernel': {'lengthscale': DeviceArray([1., 1.], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
{'kernel': {'lengthscale': DeviceArray([[1., 1.],
             [1., 1.]], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
F{'kernel': {'lengthscale': DeviceArray([1., 1.], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
{'kernel': {'lengthscale': DeviceArray([[1., 1.],
             [1., 1.]], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
F{'kernel': {'lengthscale': DeviceArray([1., 1.], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
{'kernel': {'lengthscale': DeviceArray([[1., 1.],
             [1., 1.]], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
F...

=================================== FAILURES ===================================
__________________ test_initialize[kernel_params1-RBFKernel] ___________________

    import re
    import sys
    from pytest import console_main
    if __name__ == '__main__':
        sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
>       sys.exit(console_main())

../miniconda3/envs/ajax/bin/pytest:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def console_main() -> int:
        """The CLI entry point of pytest.
    
        This function is not meant for programmable use; use `main()` instead.
        """
        # https://docs.python.org/3/library/signal.html#note-on-sigpipe
        try:
>           code = main()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/config/__init__.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = None, plugins = None

    def main(
        args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
        plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
    ) -> Union[int, ExitCode]:
        """Perform an in-process test run.
    
        :param args: List of command line arguments.
        :param plugins: List of plugin objects to be auto-registered during initialization.
    
        :returns: An exit code.
        """
        try:
            try:
                config = _prepareconfig(args, plugins)
            except ConftestImportFailure as e:
                exc_info = ExceptionInfo.from_exc_info(e.excinfo)
                tw = TerminalWriter(sys.stderr)
                tw.line(f"ImportError while loading conftest '{e.path}'.", red=True)
                exc_info.traceback = exc_info.traceback.filter(
                    filter_traceback_for_conftest_import_failure
                )
                exc_repr = (
                    exc_info.getrepr(style="short", chain=False)
                    if exc_info.traceback
                    else exc_info.exconly()
                )
                formatted_tb = str(exc_repr)
                for line in formatted_tb.splitlines():
                    tw.line(line.rstrip(), red=True)
                return ExitCode.USAGE_ERROR
            else:
                try:
>                   ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
                        config=config
                    )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/config/__init__.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_cmdline_main'>, args = ()
kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
argname = 'config', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_cmdline_main'
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...pytest.setuponly' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/setuponly.py'>>, ...]
kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_cmdline_main'
hook_impls = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...pytest.setuponly' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/setuponly.py'>>, ...]
caller_kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>

    def pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:
>       return wrap_session(config, _main)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>
doit = <function _main at 0x7fa20cbb8670>

    def wrap_session(
        config: Config, doit: Callable[[Config, "Session"], Optional[Union[int, ExitCode]]]
    ) -> Union[int, ExitCode]:
        """Skeleton command line program."""
        session = Session.from_config(config)
        session.exitstatus = ExitCode.OK
        initstate = 0
        try:
            try:
                config._do_configure()
                initstate = 1
                config.hook.pytest_sessionstart(session=session)
                initstate = 2
>               session.exitstatus = doit(config, session) or 0

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>
session = <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=11>

    def _main(config: Config, session: "Session") -> Optional[Union[int, ExitCode]]:
        """Default command line protocol for initialization, session,
        running tests and reporting."""
        config.hook.pytest_collection(session=session)
>       config.hook.pytest_runtestloop(session=session)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtestloop'>, args = ()
kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=11>}
argname = 'session', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtestloop'
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...t/main.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7fa20c7fa310>>]
kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=11>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtestloop'
hook_impls = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...t/main.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7fa20c7fa310>>]
caller_kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=11>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=11>

    def pytest_runtestloop(session: "Session") -> bool:
        if session.testsfailed and not session.config.option.continue_on_collection_errors:
            raise session.Interrupted(
                "%d error%s during collection"
                % (session.testsfailed, "s" if session.testsfailed != 1 else "")
            )
    
        if session.config.option.collectonly:
            return True
    
        for i, item in enumerate(session.items):
            nextitem = session.items[i + 1] if i + 1 < len(session.items) else None
>           item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_protocol'>, args = ()
kwargs = {'item': <Function test_initialize[kernel_params1-RBFKernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern12Kernel]>}
argname = 'nextitem', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtest_protocol'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...dule '_pytest.warnings' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/warnings.py'>>]
kwargs = {'item': <Function test_initialize[kernel_params1-RBFKernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern12Kernel]>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_protocol'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...dule '_pytest.warnings' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/warnings.py'>>]
caller_kwargs = {'item': <Function test_initialize[kernel_params1-RBFKernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern12Kernel]>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-RBFKernel]>
nextitem = <Function test_initialize[kernel_params1-Matern12Kernel]>

    def pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) -> bool:
        ihook = item.ihook
        ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)
>       runtestprotocol(item, nextitem=nextitem)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-RBFKernel]>, log = True
nextitem = <Function test_initialize[kernel_params1-Matern12Kernel]>

    def runtestprotocol(
        item: Item, log: bool = True, nextitem: Optional[Item] = None
    ) -> List[TestReport]:
        hasrequest = hasattr(item, "_request")
        if hasrequest and not item._request:  # type: ignore[attr-defined]
            # This only happens if the item is re-run, as is done by
            # pytest-rerunfailures.
            item._initrequest()  # type: ignore[attr-defined]
        rep = call_and_report(item, "setup", log)
        reports = [rep]
        if rep.passed:
            if item.config.getoption("setupshow", False):
                show_test_item(item)
            if not item.config.getoption("setuponly", False):
>               reports.append(call_and_report(item, "call", log))

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-RBFKernel]>, when = 'call'
log = True, kwds = {}
call = <CallInfo when='call' excinfo=<ExceptionInfo TypeError('eq got incompatible shapes for broadcasting: (3,), (5,).') tblen=4>>
hook = <_pytest.config.compat.PathAwareHookProxy object at 0x7fa20c94fe80>

    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
>       call = call_runtest_hook(item, when, **kwds)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-RBFKernel]>, when = 'call'
kwds = {}
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
>       return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7fa0bdeda160>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_call'>, args = ()
kwargs = {'item': <Function test_initialize[kernel_params1-RBFKernel]>}
argname = 'item', firstresult = False

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...threadexception' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Function test_initialize[kernel_params1-RBFKernel]>}
firstresult = False

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...threadexception' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Function test_initialize[kernel_params1-RBFKernel]>}
firstresult = False

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-RBFKernel]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Function test_initialize[kernel_params1-RBFKernel]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py:1761: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_pyfunc_call'>, args = ()
kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-RBFKernel]>}
argname = 'pyfuncitem', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-RBFKernel]>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-RBFKernel]>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pyfuncitem = <Function test_initialize[kernel_params1-RBFKernel]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: "Function") -> Optional[object]:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_warn_and_skip(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

kernel_fn = <class 'gpax.kernels.RBFKernel'>
kernel_params = {'lengthscale': None, 'variance': None}

    @pytest.mark.parametrize("kernel_fn", [RBFKernel, Matern12Kernel, Matern32Kernel, Matern52Kernel])
    @pytest.mark.parametrize(
        "kernel_params", [{"lengthscale": 0.5, "variance": 0.7}, {"lengthscale": None, "variance": None}]
    )
    def test_initialize(kernel_fn, kernel_params):
        kernel = kernel_fn(**kernel_params)
        key = jax.random.PRNGKey(0)
        X = jax.random.normal(key, (10, 2))
        params = kernel.initialise_params(key, X)
        ls = kernel_params["lengthscale"] if kernel_params["lengthscale"] is not None else [1.0, 1.0]
        var = kernel_params["variance"] if kernel_params["variance"] is not None else 1.0
        params_expected = {"kernel": {"lengthscale": jnp.array([ls, ls]), "variance": jnp.array(var)}}
        print(params)
        print(params_expected)
>       assert_same_pytree(params, params_expected)

tests/test_kernels.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tree1 = {'kernel': {'lengthscale': DeviceArray([1., 1.], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
tree2 = {'kernel': {'lengthscale': DeviceArray([[1., 1.],
             [1., 1.]], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}

    def assert_same_pytree(tree1, tree2):
        assert tree_util.tree_structure(tree1) == tree_util.tree_structure(tree2)
>       assert jnp.all(ravel_pytree(tree1)[0] == ravel_pytree(tree2)[0])

tests/utils.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DeviceArray([1., 1., 1.], dtype=float64)
other = DeviceArray([1., 1., 1., 1., 1.], dtype=float64)

    def deferring_binary_op(self, other):
      if hasattr(other, '__jax_array__'):
        other = other.__jax_array__()
      args = (other, self) if swap else (self, other)
      if isinstance(other, _accepted_binop_types):
>       return binary_op(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/lax_numpy.py:4658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
kwargs = {}, __tracebackhide__ = True
msg = 'TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).\n\nThe stack trace below excludes JAX-internal frames.\nThe preceding is the original exception that occurred, unmodified.\n\n--------------------'

    @util.wraps(fun)
    def reraise_with_filtered_traceback(*args, **kwargs):
      __tracebackhide__ = True
      try:
>       return fun(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/traceback_util.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
kwargs = {}, closed_fun = Wrapped function:

Core: <lambda>

in_tree = PyTreeDef(((*, *), {}))
args_flat = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]
donated_invars = (False, False)
arg = DeviceArray([1., 1., 1., 1., 1.], dtype=float64)
flat_fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

out_tree = <function transformation_with_aux.<locals>.<lambda> at 0x7fa0781a21f0>

    @api_boundary
    def cache_miss(*args, **kwargs):
      ### This first part is basically the same code as in _python_jit.
      # An alternative would be for cache_miss to accept from C++ the arguments
      # (dyn_args, donated_invars, args_flat, in_tree), since otherwise we have
      # work/code that is redundant between C++ and Python. We can try that later.
      closed_fun, in_tree, args_flat, donated_invars = _prepare_jit(
          fun, static_argnums, static_argnames, donate_argnums, args, kwargs)
      for arg in args_flat:
        _check_arg(arg)
      flat_fun, out_tree = flatten_fun(closed_fun, in_tree)
      if jax.config.jax_dynamic_shapes:
        in_type = pe.infer_lambda_input_type(None, args_flat)
        flat_fun = lu.annotate(flat_fun, in_type)
>     out_flat = xla.xla_call(
          flat_fun, *args_flat,
          device=device, backend=backend, name=flat_fun.__name__,
          donated_invars=donated_invars, inline=inline, keep_unused=keep_unused)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/api.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = xla_call
fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}

    def bind(self, fun, *args, **params):
>     return call_bind(self, fun, *args, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

primitive = xla_call
fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}
top_trace = EvalTrace(level=0/0)
fun_ = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

env_trace_todo = <function transformation_with_aux.<locals>.<lambda> at 0x7fa078093940>
tracers = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]

    def call_bind(primitive: CallPrimitive, fun, *args, **params):
      top_trace = find_top_trace(args)
      fun_, env_trace_todo = process_env_traces_call(
          fun, primitive, top_trace and top_trace.level, tuple(params.items()))
      tracers = map(top_trace.full_raise, args)
      fun_ = lu.annotate(fun_, fun.in_type)
>     outs = top_trace.process_call(primitive, fun_, tracers, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:1979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = EvalTrace(level=0/0), primitive = xla_call
f = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

tracers = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}

    def process_call(self, primitive, f, tracers, params):
>     return primitive.impl(f, *tracers, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:689: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False)

    def _xla_call_impl(fun: lu.WrappedFun, *args, device, backend, name,
                       donated_invars, inline, keep_unused: bool):
      del inline  # Only used at tracing time
      if fun.in_type is None:
        arg_specs = unsafe_map(arg_spec, args)
      else:
        # fun.in_type is used for dynamic shapes.
        if config.jax_array:
          raise NotImplementedError('Dynamic shapes do not work with Array.')
        arg_specs = [(None, getattr(x, '_device', None)) for x in args]
>     compiled_fun = xla_callable(fun, device, backend, name, donated_invars,
                                  keep_unused, *arg_specs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (None, None, '<lambda>', (False, False), False, (ShapedArray(float64[3]), None), ...)
cache = {(((<function process_env_traces_call at 0x7fa0be9c6e50>, (xla_call, 0, ((...), (...), (...), (...), (...), (...)))), ... {0, 1}, False), (<jax.linear_util.Store object at 0x7fa07816c580>, <jax.linear_util.Store object at 0x7fa07816c0d0>))}
key = (((<function process_env_traces_call at 0x7fa0be9c6e50>, (xla_call, 0, (('device', None), ('backend', None), ('name', ...,))), (), None, (None, None, '<lambda>', (False, False), False, (ShapedArray(float64[3]), None), ...), True, None, ...)
result = None

    def memoized_fun(fun: WrappedFun, *args):
      cache = fun_caches.setdefault(fun.f, {})
      if config.jax_check_tracer_leaks:
        key = (_copy_main_traces(fun.transforms), fun.params, fun.in_type, args,
               config.x64_enabled, config.jax_default_device,
               config._trace_context())
      else:
        key = (fun.transforms, fun.params, fun.in_type, args, config.x64_enabled,
               config.jax_default_device, config._trace_context())
      result = cache.get(key, None)
      if result is not None:
        ans, stores = result
        fun.populate_stores(stores)
      else:
>       ans = call(fun, *args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/linear_util.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False), keep_unused = False
arg_specs = ((ShapedArray(float64[3]), None), (ShapedArray(float64[5]), None))

    def _xla_callable_uncached(fun: lu.WrappedFun, device, backend, name,
                               donated_invars, keep_unused, *arg_specs):
      # TODO(yashkatariya): Remove the `and arg_specs` from here once
      # lower_sharding_computation supports no avals as input.
      if config.jax_array and arg_specs:
        return sharded_lowering(fun, device, backend, name,
                                donated_invars, keep_unused, *arg_specs)
      else:
>       return lower_xla_callable(fun, device, backend, name, donated_invars, False,
                                  keep_unused, *arg_specs).compile().unsafe_call

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lamb...)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>
, None, None, '<lambda>', (False, False), False, ...)
kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
      with TraceAnnotation(name, **decorator_kwargs):
>       return func(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/profiler.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False), always_lower = False, keep_unused = False
arg_specs = ((ShapedArray(float64[3]), None), (ShapedArray(float64[5]), None))
abstract_args = (ShapedArray(float64[3]), ShapedArray(float64[5]))
arg_devices = (None, None)
in_type = ((ShapedArray(float64[3]), True), (ShapedArray(float64[5]), True))

    @profiler.annotate_function
    def lower_xla_callable(
        fun: lu.WrappedFun, device, backend, name, donated_invars,
        always_lower: bool, keep_unused: bool, *arg_specs):
      """Lower into XLA.
    
      Args:
        always_lower: If `True`, even trivial programs (not doing any computation
          such as lambda x: x) will be lowered into an XLA program.
        keep_unused: If `False` (the default), arguments that JAX determines to be
          unused by `fun` *may* be dropped from resulting compiled XLA executables.
          Such arguments will not be transferred to the device nor provided to the
          underlying executable. If `True`, unused arguments will not be pruned.
      """
      if device is not None and backend is not None:
        raise ValueError("can't specify both a device and a backend for jit, "
                         "got device={} and backend={}".format(device, backend))
      abstract_args, arg_devices = util.unzip2(arg_specs)
      if fun.in_type is None:
        # Add an annotation inferred from the arguments; no dynamic axes here.
        in_type = tuple(unsafe_zip(abstract_args, itertools.repeat(True)))
        fun = lu.annotate(fun, in_type)
      else:
        assert abstract_args == (None,) * len(abstract_args)
        abstract_args = [aval for aval, _ in fun.in_type]
    
      with log_elapsed_time(f"Finished tracing + transforming {fun.__name__} "
                            "for jit in {elapsed_time} sec"):
>       jaxpr, out_type, consts = pe.trace_to_jaxpr_final2(
            fun, pe.debug_info_final(fun, "jit"))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lamb... at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True)))
kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
      with TraceAnnotation(name, **decorator_kwargs):
>       return func(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/profiler.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

debug_info = DebugInfo(func_src_info='<lambda> at /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/...e at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True))

    @profiler.annotate_function
    def trace_to_jaxpr_final2(
        fun: lu.WrappedFun, debug_info: Optional[DebugInfo] = None
      ) -> Tuple[Jaxpr, OutputType, List[Any]]:
      with core.new_base_main(DynamicJaxprTrace) as main:  # type: ignore
        main.jaxpr_stack = ()  # type: ignore
        with core.new_sublevel():
>         jaxpr, out_type, consts = trace_to_subjaxpr_dynamic2(fun, main, debug_info)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:2025: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

main = MainTrace(0,DynamicJaxprTrace)
debug_info = DebugInfo(func_src_info='<lambda> at /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/...e at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True))

    def trace_to_subjaxpr_dynamic2(
        fun: lu.WrappedFun, main: core.MainTrace,
        debug_info: Optional[DebugInfo] = None
    ) -> Tuple[Jaxpr, OutputType, List[Any]]:
      in_avals, keep_inputs = unzip2(fun.in_type)
      frame = JaxprStackFrame()
      frame.debug_info = debug_info
      with extend_jaxpr_stack(main, frame), source_info_util.reset_name_stack():
        trace = DynamicJaxprTrace(main, core.cur_sublevel())
        in_tracers = _input_type_to_tracers(trace.new_arg, in_avals)
        in_tracers_ = [t for t, keep in zip(in_tracers, keep_inputs) if keep]
>       ans = fun.call_wrapped(*in_tracers_)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
kwargs = {}, stack = [], gen = None, gen_static_args = None, out_store = None

    def call_wrapped(self, *args, **kwargs):
      """Calls the underlying function, applying the transforms.
    
      The positional `args` and keyword `kwargs` are passed to the first
      transformation generator.
      """
      stack = []
      for (gen, gen_static_args), out_store in zip(self.transforms, self.stores):
        gen = gen(*(gen_static_args + tuple(args)), **kwargs)
        args, kwargs = next(gen)
        stack.append((gen, out_store))
      gen = gen_static_args = out_store = None
    
      try:
>       ans = self.f(*args, **dict(self.params, **kwargs))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/linear_util.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x1 = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
x2 = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

>   fn = lambda x1, x2: lax_fn(*_promote_args(numpy_fn.__name__, x1, x2))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/ufuncs.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
y = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

    def eq(x: Array, y: Array) -> Array:
      r"""Elementwise equals: :math:`x = y`."""
>     return eq_p.bind(x, y)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/lax.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = eq
args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
params = {}

    def bind(self, *args, **params):
      assert (not config.jax_enable_checks or
              all(isinstance(arg, Tracer) or valid_jaxtype(arg) for arg in args)), args
>     return self.bind_with_trace(find_top_trace(args), args, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = eq, trace = DynamicJaxprTrace(level=0/1)
args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
params = {}

    def bind_with_trace(self, trace, args, params):
>     out = trace.process_primitive(self, map(trace.full_raise, args), params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DynamicJaxprTrace(level=0/1), primitive = eq
tracers = [Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>]
params = {}

    def process_primitive(self, primitive, tracers, params):
      if primitive in custom_staging_rules:
        return custom_staging_rules[primitive](self, *tracers, **params)
>     return self.default_process_primitive(primitive, tracers, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DynamicJaxprTrace(level=0/1), primitive = eq
tracers = [Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>]
params = {}

    def default_process_primitive(self, primitive, tracers, params):
      avals = [t.aval for t in tracers]
>     out_avals, effects = primitive.abstract_eval(*avals, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1662: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (ShapedArray(float64[3]), ShapedArray(float64[5])), kwargs = {}

    def abstract_eval_(*args, **kwargs):
>     return abstract_eval(*args, **kwargs), no_effects

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prim = eq
shape_rule = functools.partial(<function broadcasting_shape_rule at 0x7fa16b6f6c10>, 'eq')
dtype_rule = functools.partial(<function naryop_dtype_rule at 0x7fa16b6f6b80>, <function <lambda>.<locals>.<lambda> at 0x7fa16b71cc...>}, {<class 'numpy.complexfloating'>, <class 'numpy.floating'>, <class 'numpy.integer'>, <class 'numpy.bool_'>}], 'eq')
weak_type_rule = functools.partial(<function _naryop_weak_type_rule at 0x7fa16b6f6ca0>, 'eq')
named_shape_rule = <function standard_named_shape_rule at 0x7fa16b746f70>
avals = (ShapedArray(float64[3]), ShapedArray(float64[5])), kwargs = {}
weak_type = False, least_specialized = <class 'jax.core.ShapedArray'>

    def standard_abstract_eval(prim, shape_rule, dtype_rule, weak_type_rule,
                               named_shape_rule, *avals, **kwargs):
      assert all(isinstance(aval, core.UnshapedArray) for aval in avals), avals
      assert not prim.multiple_results
      weak_type = weak_type_rule(*avals, **kwargs)
      least_specialized = _max(map(type, avals),
                               key=operator.attrgetter('array_abstraction_level'))
      if least_specialized is core.ConcreteArray:
        out = prim.impl(*[x.val for x in avals], **kwargs)
        return core.ConcreteArray(out.dtype, out, weak_type=weak_type)
      elif least_specialized is core.ShapedArray:
>       return core.ShapedArray(shape_rule(*avals, **kwargs),
                                dtype_rule(*avals, **kwargs), weak_type=weak_type,

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/utils.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'eq', avals = (ShapedArray(float64[3]), ShapedArray(float64[5]))
shapes = [(3,), (5,)], result_shape = []

    def broadcasting_shape_rule(name, *avals):
      shapes = [aval.shape for aval in avals if aval.shape]
      if not shapes:
        return ()
      if len({len(shape) for shape in shapes}) != 1:
        msg = '{}: arrays must have same number of dimensions, got {}.'
        raise TypeError(msg.format(name, ', '.join(map(str, map(tuple, shapes)))))
      # TODO(mattjj): de-duplicate with _try_broadcast_shapes
      result_shape = []
      for ds in zip(*shapes):
        if all(core.same_referent(d, ds[0]) for d in ds[1:]):
          # if all axes are identical objects, the resulting size is the object
          result_shape.append(ds[0])
        else:
          # if all dims are equal (or 1), the result is the non-1 size
          non_1s = [d for d in ds if not core.symbolic_equal_dim(d, 1)]
          if not non_1s:
            result_shape.append(1)
          elif all(core.symbolic_equal_dim(non_1s[0], d) for d in non_1s[1:]):
            result_shape.append(non_1s[0])
          else:
>           raise TypeError(f'{name} got incompatible shapes for broadcasting: '
                            f'{", ".join(map(str, map(tuple, shapes)))}.')
E           jax._src.traceback_util.UnfilteredStackTrace: TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).
E           
E           The stack trace below excludes JAX-internal frames.
E           The preceding is the original exception that occurred, unmodified.
E           
E           --------------------

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/lax.py:1537: UnfilteredStackTrace

The above exception was the direct cause of the following exception:

kernel_fn = <class 'gpax.kernels.RBFKernel'>
kernel_params = {'lengthscale': None, 'variance': None}

    @pytest.mark.parametrize("kernel_fn", [RBFKernel, Matern12Kernel, Matern32Kernel, Matern52Kernel])
    @pytest.mark.parametrize(
        "kernel_params", [{"lengthscale": 0.5, "variance": 0.7}, {"lengthscale": None, "variance": None}]
    )
    def test_initialize(kernel_fn, kernel_params):
        kernel = kernel_fn(**kernel_params)
        key = jax.random.PRNGKey(0)
        X = jax.random.normal(key, (10, 2))
        params = kernel.initialise_params(key, X)
        ls = kernel_params["lengthscale"] if kernel_params["lengthscale"] is not None else [1.0, 1.0]
        var = kernel_params["variance"] if kernel_params["variance"] is not None else 1.0
        params_expected = {"kernel": {"lengthscale": jnp.array([ls, ls]), "variance": jnp.array(var)}}
        print(params)
        print(params_expected)
>       assert_same_pytree(params, params_expected)

tests/test_kernels.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/utils.py:8: in assert_same_pytree
    assert jnp.all(ravel_pytree(tree1)[0] == ravel_pytree(tree2)[0])
../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/lax_numpy.py:4658: in deferring_binary_op
    return binary_op(*args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x1 = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
x2 = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

>   fn = lambda x1, x2: lax_fn(*_promote_args(numpy_fn.__name__, x1, x2))
E   TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/ufuncs.py:72: TypeError
________________ test_initialize[kernel_params1-Matern12Kernel] ________________

    import re
    import sys
    from pytest import console_main
    if __name__ == '__main__':
        sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
>       sys.exit(console_main())

../miniconda3/envs/ajax/bin/pytest:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def console_main() -> int:
        """The CLI entry point of pytest.
    
        This function is not meant for programmable use; use `main()` instead.
        """
        # https://docs.python.org/3/library/signal.html#note-on-sigpipe
        try:
>           code = main()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/config/__init__.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = None, plugins = None

    def main(
        args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
        plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
    ) -> Union[int, ExitCode]:
        """Perform an in-process test run.
    
        :param args: List of command line arguments.
        :param plugins: List of plugin objects to be auto-registered during initialization.
    
        :returns: An exit code.
        """
        try:
            try:
                config = _prepareconfig(args, plugins)
            except ConftestImportFailure as e:
                exc_info = ExceptionInfo.from_exc_info(e.excinfo)
                tw = TerminalWriter(sys.stderr)
                tw.line(f"ImportError while loading conftest '{e.path}'.", red=True)
                exc_info.traceback = exc_info.traceback.filter(
                    filter_traceback_for_conftest_import_failure
                )
                exc_repr = (
                    exc_info.getrepr(style="short", chain=False)
                    if exc_info.traceback
                    else exc_info.exconly()
                )
                formatted_tb = str(exc_repr)
                for line in formatted_tb.splitlines():
                    tw.line(line.rstrip(), red=True)
                return ExitCode.USAGE_ERROR
            else:
                try:
>                   ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
                        config=config
                    )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/config/__init__.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_cmdline_main'>, args = ()
kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
argname = 'config', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_cmdline_main'
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...pytest.setuponly' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/setuponly.py'>>, ...]
kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_cmdline_main'
hook_impls = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...pytest.setuponly' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/setuponly.py'>>, ...]
caller_kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>

    def pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:
>       return wrap_session(config, _main)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>
doit = <function _main at 0x7fa20cbb8670>

    def wrap_session(
        config: Config, doit: Callable[[Config, "Session"], Optional[Union[int, ExitCode]]]
    ) -> Union[int, ExitCode]:
        """Skeleton command line program."""
        session = Session.from_config(config)
        session.exitstatus = ExitCode.OK
        initstate = 0
        try:
            try:
                config._do_configure()
                initstate = 1
                config.hook.pytest_sessionstart(session=session)
                initstate = 2
>               session.exitstatus = doit(config, session) or 0

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>
session = <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=11>

    def _main(config: Config, session: "Session") -> Optional[Union[int, ExitCode]]:
        """Default command line protocol for initialization, session,
        running tests and reporting."""
        config.hook.pytest_collection(session=session)
>       config.hook.pytest_runtestloop(session=session)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtestloop'>, args = ()
kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=11>}
argname = 'session', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtestloop'
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...t/main.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7fa20c7fa310>>]
kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=11>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtestloop'
hook_impls = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...t/main.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7fa20c7fa310>>]
caller_kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=11>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=1 testscollected=11>

    def pytest_runtestloop(session: "Session") -> bool:
        if session.testsfailed and not session.config.option.continue_on_collection_errors:
            raise session.Interrupted(
                "%d error%s during collection"
                % (session.testsfailed, "s" if session.testsfailed != 1 else "")
            )
    
        if session.config.option.collectonly:
            return True
    
        for i, item in enumerate(session.items):
            nextitem = session.items[i + 1] if i + 1 < len(session.items) else None
>           item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_protocol'>, args = ()
kwargs = {'item': <Function test_initialize[kernel_params1-Matern12Kernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern32Kernel]>}
argname = 'nextitem', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtest_protocol'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...dule '_pytest.warnings' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/warnings.py'>>]
kwargs = {'item': <Function test_initialize[kernel_params1-Matern12Kernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern32Kernel]>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_protocol'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...dule '_pytest.warnings' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/warnings.py'>>]
caller_kwargs = {'item': <Function test_initialize[kernel_params1-Matern12Kernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern32Kernel]>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern12Kernel]>
nextitem = <Function test_initialize[kernel_params1-Matern32Kernel]>

    def pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) -> bool:
        ihook = item.ihook
        ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)
>       runtestprotocol(item, nextitem=nextitem)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern12Kernel]>, log = True
nextitem = <Function test_initialize[kernel_params1-Matern32Kernel]>

    def runtestprotocol(
        item: Item, log: bool = True, nextitem: Optional[Item] = None
    ) -> List[TestReport]:
        hasrequest = hasattr(item, "_request")
        if hasrequest and not item._request:  # type: ignore[attr-defined]
            # This only happens if the item is re-run, as is done by
            # pytest-rerunfailures.
            item._initrequest()  # type: ignore[attr-defined]
        rep = call_and_report(item, "setup", log)
        reports = [rep]
        if rep.passed:
            if item.config.getoption("setupshow", False):
                show_test_item(item)
            if not item.config.getoption("setuponly", False):
>               reports.append(call_and_report(item, "call", log))

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern12Kernel]>, when = 'call'
log = True, kwds = {}
call = <CallInfo when='call' excinfo=<ExceptionInfo TypeError('eq got incompatible shapes for broadcasting: (3,), (5,).') tblen=4>>
hook = <_pytest.config.compat.PathAwareHookProxy object at 0x7fa20c94fe80>

    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
>       call = call_runtest_hook(item, when, **kwds)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern12Kernel]>, when = 'call'
kwds = {}
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
>       return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7fa078170dc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_call'>, args = ()
kwargs = {'item': <Function test_initialize[kernel_params1-Matern12Kernel]>}
argname = 'item', firstresult = False

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...threadexception' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Function test_initialize[kernel_params1-Matern12Kernel]>}
firstresult = False

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...threadexception' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Function test_initialize[kernel_params1-Matern12Kernel]>}
firstresult = False

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern12Kernel]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Function test_initialize[kernel_params1-Matern12Kernel]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py:1761: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_pyfunc_call'>, args = ()
kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern12Kernel]>}
argname = 'pyfuncitem', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern12Kernel]>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern12Kernel]>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pyfuncitem = <Function test_initialize[kernel_params1-Matern12Kernel]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: "Function") -> Optional[object]:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_warn_and_skip(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

kernel_fn = <class 'gpax.kernels.Matern12Kernel'>
kernel_params = {'lengthscale': None, 'variance': None}

    @pytest.mark.parametrize("kernel_fn", [RBFKernel, Matern12Kernel, Matern32Kernel, Matern52Kernel])
    @pytest.mark.parametrize(
        "kernel_params", [{"lengthscale": 0.5, "variance": 0.7}, {"lengthscale": None, "variance": None}]
    )
    def test_initialize(kernel_fn, kernel_params):
        kernel = kernel_fn(**kernel_params)
        key = jax.random.PRNGKey(0)
        X = jax.random.normal(key, (10, 2))
        params = kernel.initialise_params(key, X)
        ls = kernel_params["lengthscale"] if kernel_params["lengthscale"] is not None else [1.0, 1.0]
        var = kernel_params["variance"] if kernel_params["variance"] is not None else 1.0
        params_expected = {"kernel": {"lengthscale": jnp.array([ls, ls]), "variance": jnp.array(var)}}
        print(params)
        print(params_expected)
>       assert_same_pytree(params, params_expected)

tests/test_kernels.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tree1 = {'kernel': {'lengthscale': DeviceArray([1., 1.], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
tree2 = {'kernel': {'lengthscale': DeviceArray([[1., 1.],
             [1., 1.]], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}

    def assert_same_pytree(tree1, tree2):
        assert tree_util.tree_structure(tree1) == tree_util.tree_structure(tree2)
>       assert jnp.all(ravel_pytree(tree1)[0] == ravel_pytree(tree2)[0])

tests/utils.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DeviceArray([1., 1., 1.], dtype=float64)
other = DeviceArray([1., 1., 1., 1., 1.], dtype=float64)

    def deferring_binary_op(self, other):
      if hasattr(other, '__jax_array__'):
        other = other.__jax_array__()
      args = (other, self) if swap else (self, other)
      if isinstance(other, _accepted_binop_types):
>       return binary_op(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/lax_numpy.py:4658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
kwargs = {}, __tracebackhide__ = True
msg = 'TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).\n\nThe stack trace below excludes JAX-internal frames.\nThe preceding is the original exception that occurred, unmodified.\n\n--------------------'

    @util.wraps(fun)
    def reraise_with_filtered_traceback(*args, **kwargs):
      __tracebackhide__ = True
      try:
>       return fun(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/traceback_util.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
kwargs = {}, closed_fun = Wrapped function:

Core: <lambda>

in_tree = PyTreeDef(((*, *), {}))
args_flat = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]
donated_invars = (False, False)
arg = DeviceArray([1., 1., 1., 1., 1.], dtype=float64)
flat_fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

out_tree = <function transformation_with_aux.<locals>.<lambda> at 0x7fa0781ee8b0>

    @api_boundary
    def cache_miss(*args, **kwargs):
      ### This first part is basically the same code as in _python_jit.
      # An alternative would be for cache_miss to accept from C++ the arguments
      # (dyn_args, donated_invars, args_flat, in_tree), since otherwise we have
      # work/code that is redundant between C++ and Python. We can try that later.
      closed_fun, in_tree, args_flat, donated_invars = _prepare_jit(
          fun, static_argnums, static_argnames, donate_argnums, args, kwargs)
      for arg in args_flat:
        _check_arg(arg)
      flat_fun, out_tree = flatten_fun(closed_fun, in_tree)
      if jax.config.jax_dynamic_shapes:
        in_type = pe.infer_lambda_input_type(None, args_flat)
        flat_fun = lu.annotate(flat_fun, in_type)
>     out_flat = xla.xla_call(
          flat_fun, *args_flat,
          device=device, backend=backend, name=flat_fun.__name__,
          donated_invars=donated_invars, inline=inline, keep_unused=keep_unused)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/api.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = xla_call
fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}

    def bind(self, fun, *args, **params):
>     return call_bind(self, fun, *args, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

primitive = xla_call
fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}
top_trace = EvalTrace(level=0/0)
fun_ = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

env_trace_todo = <function transformation_with_aux.<locals>.<lambda> at 0x7fa070367040>
tracers = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]

    def call_bind(primitive: CallPrimitive, fun, *args, **params):
      top_trace = find_top_trace(args)
      fun_, env_trace_todo = process_env_traces_call(
          fun, primitive, top_trace and top_trace.level, tuple(params.items()))
      tracers = map(top_trace.full_raise, args)
      fun_ = lu.annotate(fun_, fun.in_type)
>     outs = top_trace.process_call(primitive, fun_, tracers, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:1979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = EvalTrace(level=0/0), primitive = xla_call
f = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

tracers = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}

    def process_call(self, primitive, f, tracers, params):
>     return primitive.impl(f, *tracers, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:689: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False)

    def _xla_call_impl(fun: lu.WrappedFun, *args, device, backend, name,
                       donated_invars, inline, keep_unused: bool):
      del inline  # Only used at tracing time
      if fun.in_type is None:
        arg_specs = unsafe_map(arg_spec, args)
      else:
        # fun.in_type is used for dynamic shapes.
        if config.jax_array:
          raise NotImplementedError('Dynamic shapes do not work with Array.')
        arg_specs = [(None, getattr(x, '_device', None)) for x in args]
>     compiled_fun = xla_callable(fun, device, backend, name, donated_invars,
                                  keep_unused, *arg_specs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (None, None, '<lambda>', (False, False), False, (ShapedArray(float64[3]), None), ...)
cache = {(((<function process_env_traces_call at 0x7fa0be9c6e50>, (xla_call, 0, ((...), (...), (...), (...), (...), (...)))), ... {0, 1}, False), (<jax.linear_util.Store object at 0x7fa07816c580>, <jax.linear_util.Store object at 0x7fa07816c0d0>))}
key = (((<function process_env_traces_call at 0x7fa0be9c6e50>, (xla_call, 0, (('device', None), ('backend', None), ('name', ...,))), (), None, (None, None, '<lambda>', (False, False), False, (ShapedArray(float64[3]), None), ...), True, None, ...)
result = None

    def memoized_fun(fun: WrappedFun, *args):
      cache = fun_caches.setdefault(fun.f, {})
      if config.jax_check_tracer_leaks:
        key = (_copy_main_traces(fun.transforms), fun.params, fun.in_type, args,
               config.x64_enabled, config.jax_default_device,
               config._trace_context())
      else:
        key = (fun.transforms, fun.params, fun.in_type, args, config.x64_enabled,
               config.jax_default_device, config._trace_context())
      result = cache.get(key, None)
      if result is not None:
        ans, stores = result
        fun.populate_stores(stores)
      else:
>       ans = call(fun, *args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/linear_util.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False), keep_unused = False
arg_specs = ((ShapedArray(float64[3]), None), (ShapedArray(float64[5]), None))

    def _xla_callable_uncached(fun: lu.WrappedFun, device, backend, name,
                               donated_invars, keep_unused, *arg_specs):
      # TODO(yashkatariya): Remove the `and arg_specs` from here once
      # lower_sharding_computation supports no avals as input.
      if config.jax_array and arg_specs:
        return sharded_lowering(fun, device, backend, name,
                                donated_invars, keep_unused, *arg_specs)
      else:
>       return lower_xla_callable(fun, device, backend, name, donated_invars, False,
                                  keep_unused, *arg_specs).compile().unsafe_call

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lamb...)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>
, None, None, '<lambda>', (False, False), False, ...)
kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
      with TraceAnnotation(name, **decorator_kwargs):
>       return func(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/profiler.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False), always_lower = False, keep_unused = False
arg_specs = ((ShapedArray(float64[3]), None), (ShapedArray(float64[5]), None))
abstract_args = (ShapedArray(float64[3]), ShapedArray(float64[5]))
arg_devices = (None, None)
in_type = ((ShapedArray(float64[3]), True), (ShapedArray(float64[5]), True))

    @profiler.annotate_function
    def lower_xla_callable(
        fun: lu.WrappedFun, device, backend, name, donated_invars,
        always_lower: bool, keep_unused: bool, *arg_specs):
      """Lower into XLA.
    
      Args:
        always_lower: If `True`, even trivial programs (not doing any computation
          such as lambda x: x) will be lowered into an XLA program.
        keep_unused: If `False` (the default), arguments that JAX determines to be
          unused by `fun` *may* be dropped from resulting compiled XLA executables.
          Such arguments will not be transferred to the device nor provided to the
          underlying executable. If `True`, unused arguments will not be pruned.
      """
      if device is not None and backend is not None:
        raise ValueError("can't specify both a device and a backend for jit, "
                         "got device={} and backend={}".format(device, backend))
      abstract_args, arg_devices = util.unzip2(arg_specs)
      if fun.in_type is None:
        # Add an annotation inferred from the arguments; no dynamic axes here.
        in_type = tuple(unsafe_zip(abstract_args, itertools.repeat(True)))
        fun = lu.annotate(fun, in_type)
      else:
        assert abstract_args == (None,) * len(abstract_args)
        abstract_args = [aval for aval, _ in fun.in_type]
    
      with log_elapsed_time(f"Finished tracing + transforming {fun.__name__} "
                            "for jit in {elapsed_time} sec"):
>       jaxpr, out_type, consts = pe.trace_to_jaxpr_final2(
            fun, pe.debug_info_final(fun, "jit"))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lamb... at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True)))
kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
      with TraceAnnotation(name, **decorator_kwargs):
>       return func(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/profiler.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

debug_info = DebugInfo(func_src_info='<lambda> at /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/...e at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True))

    @profiler.annotate_function
    def trace_to_jaxpr_final2(
        fun: lu.WrappedFun, debug_info: Optional[DebugInfo] = None
      ) -> Tuple[Jaxpr, OutputType, List[Any]]:
      with core.new_base_main(DynamicJaxprTrace) as main:  # type: ignore
        main.jaxpr_stack = ()  # type: ignore
        with core.new_sublevel():
>         jaxpr, out_type, consts = trace_to_subjaxpr_dynamic2(fun, main, debug_info)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:2025: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

main = MainTrace(0,DynamicJaxprTrace)
debug_info = DebugInfo(func_src_info='<lambda> at /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/...e at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True))

    def trace_to_subjaxpr_dynamic2(
        fun: lu.WrappedFun, main: core.MainTrace,
        debug_info: Optional[DebugInfo] = None
    ) -> Tuple[Jaxpr, OutputType, List[Any]]:
      in_avals, keep_inputs = unzip2(fun.in_type)
      frame = JaxprStackFrame()
      frame.debug_info = debug_info
      with extend_jaxpr_stack(main, frame), source_info_util.reset_name_stack():
        trace = DynamicJaxprTrace(main, core.cur_sublevel())
        in_tracers = _input_type_to_tracers(trace.new_arg, in_avals)
        in_tracers_ = [t for t, keep in zip(in_tracers, keep_inputs) if keep]
>       ans = fun.call_wrapped(*in_tracers_)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
kwargs = {}, stack = [], gen = None, gen_static_args = None, out_store = None

    def call_wrapped(self, *args, **kwargs):
      """Calls the underlying function, applying the transforms.
    
      The positional `args` and keyword `kwargs` are passed to the first
      transformation generator.
      """
      stack = []
      for (gen, gen_static_args), out_store in zip(self.transforms, self.stores):
        gen = gen(*(gen_static_args + tuple(args)), **kwargs)
        args, kwargs = next(gen)
        stack.append((gen, out_store))
      gen = gen_static_args = out_store = None
    
      try:
>       ans = self.f(*args, **dict(self.params, **kwargs))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/linear_util.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x1 = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
x2 = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

>   fn = lambda x1, x2: lax_fn(*_promote_args(numpy_fn.__name__, x1, x2))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/ufuncs.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
y = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

    def eq(x: Array, y: Array) -> Array:
      r"""Elementwise equals: :math:`x = y`."""
>     return eq_p.bind(x, y)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/lax.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = eq
args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
params = {}

    def bind(self, *args, **params):
      assert (not config.jax_enable_checks or
              all(isinstance(arg, Tracer) or valid_jaxtype(arg) for arg in args)), args
>     return self.bind_with_trace(find_top_trace(args), args, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = eq, trace = DynamicJaxprTrace(level=0/1)
args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
params = {}

    def bind_with_trace(self, trace, args, params):
>     out = trace.process_primitive(self, map(trace.full_raise, args), params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DynamicJaxprTrace(level=0/1), primitive = eq
tracers = [Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>]
params = {}

    def process_primitive(self, primitive, tracers, params):
      if primitive in custom_staging_rules:
        return custom_staging_rules[primitive](self, *tracers, **params)
>     return self.default_process_primitive(primitive, tracers, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DynamicJaxprTrace(level=0/1), primitive = eq
tracers = [Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>]
params = {}

    def default_process_primitive(self, primitive, tracers, params):
      avals = [t.aval for t in tracers]
>     out_avals, effects = primitive.abstract_eval(*avals, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1662: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (ShapedArray(float64[3]), ShapedArray(float64[5])), kwargs = {}

    def abstract_eval_(*args, **kwargs):
>     return abstract_eval(*args, **kwargs), no_effects

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prim = eq
shape_rule = functools.partial(<function broadcasting_shape_rule at 0x7fa16b6f6c10>, 'eq')
dtype_rule = functools.partial(<function naryop_dtype_rule at 0x7fa16b6f6b80>, <function <lambda>.<locals>.<lambda> at 0x7fa16b71cc...>}, {<class 'numpy.complexfloating'>, <class 'numpy.floating'>, <class 'numpy.integer'>, <class 'numpy.bool_'>}], 'eq')
weak_type_rule = functools.partial(<function _naryop_weak_type_rule at 0x7fa16b6f6ca0>, 'eq')
named_shape_rule = <function standard_named_shape_rule at 0x7fa16b746f70>
avals = (ShapedArray(float64[3]), ShapedArray(float64[5])), kwargs = {}
weak_type = False, least_specialized = <class 'jax.core.ShapedArray'>

    def standard_abstract_eval(prim, shape_rule, dtype_rule, weak_type_rule,
                               named_shape_rule, *avals, **kwargs):
      assert all(isinstance(aval, core.UnshapedArray) for aval in avals), avals
      assert not prim.multiple_results
      weak_type = weak_type_rule(*avals, **kwargs)
      least_specialized = _max(map(type, avals),
                               key=operator.attrgetter('array_abstraction_level'))
      if least_specialized is core.ConcreteArray:
        out = prim.impl(*[x.val for x in avals], **kwargs)
        return core.ConcreteArray(out.dtype, out, weak_type=weak_type)
      elif least_specialized is core.ShapedArray:
>       return core.ShapedArray(shape_rule(*avals, **kwargs),
                                dtype_rule(*avals, **kwargs), weak_type=weak_type,

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/utils.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'eq', avals = (ShapedArray(float64[3]), ShapedArray(float64[5]))
shapes = [(3,), (5,)], result_shape = []

    def broadcasting_shape_rule(name, *avals):
      shapes = [aval.shape for aval in avals if aval.shape]
      if not shapes:
        return ()
      if len({len(shape) for shape in shapes}) != 1:
        msg = '{}: arrays must have same number of dimensions, got {}.'
        raise TypeError(msg.format(name, ', '.join(map(str, map(tuple, shapes)))))
      # TODO(mattjj): de-duplicate with _try_broadcast_shapes
      result_shape = []
      for ds in zip(*shapes):
        if all(core.same_referent(d, ds[0]) for d in ds[1:]):
          # if all axes are identical objects, the resulting size is the object
          result_shape.append(ds[0])
        else:
          # if all dims are equal (or 1), the result is the non-1 size
          non_1s = [d for d in ds if not core.symbolic_equal_dim(d, 1)]
          if not non_1s:
            result_shape.append(1)
          elif all(core.symbolic_equal_dim(non_1s[0], d) for d in non_1s[1:]):
            result_shape.append(non_1s[0])
          else:
>           raise TypeError(f'{name} got incompatible shapes for broadcasting: '
                            f'{", ".join(map(str, map(tuple, shapes)))}.')
E           jax._src.traceback_util.UnfilteredStackTrace: TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).
E           
E           The stack trace below excludes JAX-internal frames.
E           The preceding is the original exception that occurred, unmodified.
E           
E           --------------------

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/lax.py:1537: UnfilteredStackTrace

The above exception was the direct cause of the following exception:

kernel_fn = <class 'gpax.kernels.Matern12Kernel'>
kernel_params = {'lengthscale': None, 'variance': None}

    @pytest.mark.parametrize("kernel_fn", [RBFKernel, Matern12Kernel, Matern32Kernel, Matern52Kernel])
    @pytest.mark.parametrize(
        "kernel_params", [{"lengthscale": 0.5, "variance": 0.7}, {"lengthscale": None, "variance": None}]
    )
    def test_initialize(kernel_fn, kernel_params):
        kernel = kernel_fn(**kernel_params)
        key = jax.random.PRNGKey(0)
        X = jax.random.normal(key, (10, 2))
        params = kernel.initialise_params(key, X)
        ls = kernel_params["lengthscale"] if kernel_params["lengthscale"] is not None else [1.0, 1.0]
        var = kernel_params["variance"] if kernel_params["variance"] is not None else 1.0
        params_expected = {"kernel": {"lengthscale": jnp.array([ls, ls]), "variance": jnp.array(var)}}
        print(params)
        print(params_expected)
>       assert_same_pytree(params, params_expected)

tests/test_kernels.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/utils.py:8: in assert_same_pytree
    assert jnp.all(ravel_pytree(tree1)[0] == ravel_pytree(tree2)[0])
../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/lax_numpy.py:4658: in deferring_binary_op
    return binary_op(*args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x1 = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
x2 = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

>   fn = lambda x1, x2: lax_fn(*_promote_args(numpy_fn.__name__, x1, x2))
E   TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/ufuncs.py:72: TypeError
________________ test_initialize[kernel_params1-Matern32Kernel] ________________

    import re
    import sys
    from pytest import console_main
    if __name__ == '__main__':
        sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
>       sys.exit(console_main())

../miniconda3/envs/ajax/bin/pytest:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def console_main() -> int:
        """The CLI entry point of pytest.
    
        This function is not meant for programmable use; use `main()` instead.
        """
        # https://docs.python.org/3/library/signal.html#note-on-sigpipe
        try:
>           code = main()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/config/__init__.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = None, plugins = None

    def main(
        args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
        plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
    ) -> Union[int, ExitCode]:
        """Perform an in-process test run.
    
        :param args: List of command line arguments.
        :param plugins: List of plugin objects to be auto-registered during initialization.
    
        :returns: An exit code.
        """
        try:
            try:
                config = _prepareconfig(args, plugins)
            except ConftestImportFailure as e:
                exc_info = ExceptionInfo.from_exc_info(e.excinfo)
                tw = TerminalWriter(sys.stderr)
                tw.line(f"ImportError while loading conftest '{e.path}'.", red=True)
                exc_info.traceback = exc_info.traceback.filter(
                    filter_traceback_for_conftest_import_failure
                )
                exc_repr = (
                    exc_info.getrepr(style="short", chain=False)
                    if exc_info.traceback
                    else exc_info.exconly()
                )
                formatted_tb = str(exc_repr)
                for line in formatted_tb.splitlines():
                    tw.line(line.rstrip(), red=True)
                return ExitCode.USAGE_ERROR
            else:
                try:
>                   ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
                        config=config
                    )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/config/__init__.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_cmdline_main'>, args = ()
kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
argname = 'config', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_cmdline_main'
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...pytest.setuponly' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/setuponly.py'>>, ...]
kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_cmdline_main'
hook_impls = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...pytest.setuponly' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/setuponly.py'>>, ...]
caller_kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>

    def pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:
>       return wrap_session(config, _main)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>
doit = <function _main at 0x7fa20cbb8670>

    def wrap_session(
        config: Config, doit: Callable[[Config, "Session"], Optional[Union[int, ExitCode]]]
    ) -> Union[int, ExitCode]:
        """Skeleton command line program."""
        session = Session.from_config(config)
        session.exitstatus = ExitCode.OK
        initstate = 0
        try:
            try:
                config._do_configure()
                initstate = 1
                config.hook.pytest_sessionstart(session=session)
                initstate = 2
>               session.exitstatus = doit(config, session) or 0

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>
session = <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=11>

    def _main(config: Config, session: "Session") -> Optional[Union[int, ExitCode]]:
        """Default command line protocol for initialization, session,
        running tests and reporting."""
        config.hook.pytest_collection(session=session)
>       config.hook.pytest_runtestloop(session=session)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtestloop'>, args = ()
kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=11>}
argname = 'session', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtestloop'
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...t/main.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7fa20c7fa310>>]
kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=11>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtestloop'
hook_impls = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...t/main.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7fa20c7fa310>>]
caller_kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=11>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=2 testscollected=11>

    def pytest_runtestloop(session: "Session") -> bool:
        if session.testsfailed and not session.config.option.continue_on_collection_errors:
            raise session.Interrupted(
                "%d error%s during collection"
                % (session.testsfailed, "s" if session.testsfailed != 1 else "")
            )
    
        if session.config.option.collectonly:
            return True
    
        for i, item in enumerate(session.items):
            nextitem = session.items[i + 1] if i + 1 < len(session.items) else None
>           item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_protocol'>, args = ()
kwargs = {'item': <Function test_initialize[kernel_params1-Matern32Kernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern52Kernel]>}
argname = 'nextitem', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtest_protocol'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...dule '_pytest.warnings' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/warnings.py'>>]
kwargs = {'item': <Function test_initialize[kernel_params1-Matern32Kernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern52Kernel]>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_protocol'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...dule '_pytest.warnings' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/warnings.py'>>]
caller_kwargs = {'item': <Function test_initialize[kernel_params1-Matern32Kernel]>, 'nextitem': <Function test_initialize[kernel_params1-Matern52Kernel]>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern32Kernel]>
nextitem = <Function test_initialize[kernel_params1-Matern52Kernel]>

    def pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) -> bool:
        ihook = item.ihook
        ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)
>       runtestprotocol(item, nextitem=nextitem)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern32Kernel]>, log = True
nextitem = <Function test_initialize[kernel_params1-Matern52Kernel]>

    def runtestprotocol(
        item: Item, log: bool = True, nextitem: Optional[Item] = None
    ) -> List[TestReport]:
        hasrequest = hasattr(item, "_request")
        if hasrequest and not item._request:  # type: ignore[attr-defined]
            # This only happens if the item is re-run, as is done by
            # pytest-rerunfailures.
            item._initrequest()  # type: ignore[attr-defined]
        rep = call_and_report(item, "setup", log)
        reports = [rep]
        if rep.passed:
            if item.config.getoption("setupshow", False):
                show_test_item(item)
            if not item.config.getoption("setuponly", False):
>               reports.append(call_and_report(item, "call", log))

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern32Kernel]>, when = 'call'
log = True, kwds = {}
call = <CallInfo when='call' excinfo=<ExceptionInfo TypeError('eq got incompatible shapes for broadcasting: (3,), (5,).') tblen=4>>
hook = <_pytest.config.compat.PathAwareHookProxy object at 0x7fa20c94fe80>

    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
>       call = call_runtest_hook(item, when, **kwds)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern32Kernel]>, when = 'call'
kwds = {}
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
>       return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7fa07070ed30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_call'>, args = ()
kwargs = {'item': <Function test_initialize[kernel_params1-Matern32Kernel]>}
argname = 'item', firstresult = False

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...threadexception' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Function test_initialize[kernel_params1-Matern32Kernel]>}
firstresult = False

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...threadexception' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Function test_initialize[kernel_params1-Matern32Kernel]>}
firstresult = False

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern32Kernel]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Function test_initialize[kernel_params1-Matern32Kernel]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py:1761: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_pyfunc_call'>, args = ()
kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern32Kernel]>}
argname = 'pyfuncitem', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern32Kernel]>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern32Kernel]>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pyfuncitem = <Function test_initialize[kernel_params1-Matern32Kernel]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: "Function") -> Optional[object]:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_warn_and_skip(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

kernel_fn = <class 'gpax.kernels.Matern32Kernel'>
kernel_params = {'lengthscale': None, 'variance': None}

    @pytest.mark.parametrize("kernel_fn", [RBFKernel, Matern12Kernel, Matern32Kernel, Matern52Kernel])
    @pytest.mark.parametrize(
        "kernel_params", [{"lengthscale": 0.5, "variance": 0.7}, {"lengthscale": None, "variance": None}]
    )
    def test_initialize(kernel_fn, kernel_params):
        kernel = kernel_fn(**kernel_params)
        key = jax.random.PRNGKey(0)
        X = jax.random.normal(key, (10, 2))
        params = kernel.initialise_params(key, X)
        ls = kernel_params["lengthscale"] if kernel_params["lengthscale"] is not None else [1.0, 1.0]
        var = kernel_params["variance"] if kernel_params["variance"] is not None else 1.0
        params_expected = {"kernel": {"lengthscale": jnp.array([ls, ls]), "variance": jnp.array(var)}}
        print(params)
        print(params_expected)
>       assert_same_pytree(params, params_expected)

tests/test_kernels.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tree1 = {'kernel': {'lengthscale': DeviceArray([1., 1.], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
tree2 = {'kernel': {'lengthscale': DeviceArray([[1., 1.],
             [1., 1.]], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}

    def assert_same_pytree(tree1, tree2):
        assert tree_util.tree_structure(tree1) == tree_util.tree_structure(tree2)
>       assert jnp.all(ravel_pytree(tree1)[0] == ravel_pytree(tree2)[0])

tests/utils.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DeviceArray([1., 1., 1.], dtype=float64)
other = DeviceArray([1., 1., 1., 1., 1.], dtype=float64)

    def deferring_binary_op(self, other):
      if hasattr(other, '__jax_array__'):
        other = other.__jax_array__()
      args = (other, self) if swap else (self, other)
      if isinstance(other, _accepted_binop_types):
>       return binary_op(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/lax_numpy.py:4658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
kwargs = {}, __tracebackhide__ = True
msg = 'TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).\n\nThe stack trace below excludes JAX-internal frames.\nThe preceding is the original exception that occurred, unmodified.\n\n--------------------'

    @util.wraps(fun)
    def reraise_with_filtered_traceback(*args, **kwargs):
      __tracebackhide__ = True
      try:
>       return fun(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/traceback_util.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
kwargs = {}, closed_fun = Wrapped function:

Core: <lambda>

in_tree = PyTreeDef(((*, *), {}))
args_flat = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]
donated_invars = (False, False)
arg = DeviceArray([1., 1., 1., 1., 1.], dtype=float64)
flat_fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

out_tree = <function transformation_with_aux.<locals>.<lambda> at 0x7fa0781a2160>

    @api_boundary
    def cache_miss(*args, **kwargs):
      ### This first part is basically the same code as in _python_jit.
      # An alternative would be for cache_miss to accept from C++ the arguments
      # (dyn_args, donated_invars, args_flat, in_tree), since otherwise we have
      # work/code that is redundant between C++ and Python. We can try that later.
      closed_fun, in_tree, args_flat, donated_invars = _prepare_jit(
          fun, static_argnums, static_argnames, donate_argnums, args, kwargs)
      for arg in args_flat:
        _check_arg(arg)
      flat_fun, out_tree = flatten_fun(closed_fun, in_tree)
      if jax.config.jax_dynamic_shapes:
        in_type = pe.infer_lambda_input_type(None, args_flat)
        flat_fun = lu.annotate(flat_fun, in_type)
>     out_flat = xla.xla_call(
          flat_fun, *args_flat,
          device=device, backend=backend, name=flat_fun.__name__,
          donated_invars=donated_invars, inline=inline, keep_unused=keep_unused)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/api.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = xla_call
fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}

    def bind(self, fun, *args, **params):
>     return call_bind(self, fun, *args, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

primitive = xla_call
fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}
top_trace = EvalTrace(level=0/0)
fun_ = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

env_trace_todo = <function transformation_with_aux.<locals>.<lambda> at 0x7fa04c2e18b0>
tracers = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]

    def call_bind(primitive: CallPrimitive, fun, *args, **params):
      top_trace = find_top_trace(args)
      fun_, env_trace_todo = process_env_traces_call(
          fun, primitive, top_trace and top_trace.level, tuple(params.items()))
      tracers = map(top_trace.full_raise, args)
      fun_ = lu.annotate(fun_, fun.in_type)
>     outs = top_trace.process_call(primitive, fun_, tracers, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:1979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = EvalTrace(level=0/0), primitive = xla_call
f = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

tracers = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}

    def process_call(self, primitive, f, tracers, params):
>     return primitive.impl(f, *tracers, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:689: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False)

    def _xla_call_impl(fun: lu.WrappedFun, *args, device, backend, name,
                       donated_invars, inline, keep_unused: bool):
      del inline  # Only used at tracing time
      if fun.in_type is None:
        arg_specs = unsafe_map(arg_spec, args)
      else:
        # fun.in_type is used for dynamic shapes.
        if config.jax_array:
          raise NotImplementedError('Dynamic shapes do not work with Array.')
        arg_specs = [(None, getattr(x, '_device', None)) for x in args]
>     compiled_fun = xla_callable(fun, device, backend, name, donated_invars,
                                  keep_unused, *arg_specs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (None, None, '<lambda>', (False, False), False, (ShapedArray(float64[3]), None), ...)
cache = {(((<function process_env_traces_call at 0x7fa0be9c6e50>, (xla_call, 0, ((...), (...), (...), (...), (...), (...)))), ... {0, 1}, False), (<jax.linear_util.Store object at 0x7fa07816c580>, <jax.linear_util.Store object at 0x7fa07816c0d0>))}
key = (((<function process_env_traces_call at 0x7fa0be9c6e50>, (xla_call, 0, (('device', None), ('backend', None), ('name', ...,))), (), None, (None, None, '<lambda>', (False, False), False, (ShapedArray(float64[3]), None), ...), True, None, ...)
result = None

    def memoized_fun(fun: WrappedFun, *args):
      cache = fun_caches.setdefault(fun.f, {})
      if config.jax_check_tracer_leaks:
        key = (_copy_main_traces(fun.transforms), fun.params, fun.in_type, args,
               config.x64_enabled, config.jax_default_device,
               config._trace_context())
      else:
        key = (fun.transforms, fun.params, fun.in_type, args, config.x64_enabled,
               config.jax_default_device, config._trace_context())
      result = cache.get(key, None)
      if result is not None:
        ans, stores = result
        fun.populate_stores(stores)
      else:
>       ans = call(fun, *args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/linear_util.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False), keep_unused = False
arg_specs = ((ShapedArray(float64[3]), None), (ShapedArray(float64[5]), None))

    def _xla_callable_uncached(fun: lu.WrappedFun, device, backend, name,
                               donated_invars, keep_unused, *arg_specs):
      # TODO(yashkatariya): Remove the `and arg_specs` from here once
      # lower_sharding_computation supports no avals as input.
      if config.jax_array and arg_specs:
        return sharded_lowering(fun, device, backend, name,
                                donated_invars, keep_unused, *arg_specs)
      else:
>       return lower_xla_callable(fun, device, backend, name, donated_invars, False,
                                  keep_unused, *arg_specs).compile().unsafe_call

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lamb...)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>
, None, None, '<lambda>', (False, False), False, ...)
kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
      with TraceAnnotation(name, **decorator_kwargs):
>       return func(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/profiler.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False), always_lower = False, keep_unused = False
arg_specs = ((ShapedArray(float64[3]), None), (ShapedArray(float64[5]), None))
abstract_args = (ShapedArray(float64[3]), ShapedArray(float64[5]))
arg_devices = (None, None)
in_type = ((ShapedArray(float64[3]), True), (ShapedArray(float64[5]), True))

    @profiler.annotate_function
    def lower_xla_callable(
        fun: lu.WrappedFun, device, backend, name, donated_invars,
        always_lower: bool, keep_unused: bool, *arg_specs):
      """Lower into XLA.
    
      Args:
        always_lower: If `True`, even trivial programs (not doing any computation
          such as lambda x: x) will be lowered into an XLA program.
        keep_unused: If `False` (the default), arguments that JAX determines to be
          unused by `fun` *may* be dropped from resulting compiled XLA executables.
          Such arguments will not be transferred to the device nor provided to the
          underlying executable. If `True`, unused arguments will not be pruned.
      """
      if device is not None and backend is not None:
        raise ValueError("can't specify both a device and a backend for jit, "
                         "got device={} and backend={}".format(device, backend))
      abstract_args, arg_devices = util.unzip2(arg_specs)
      if fun.in_type is None:
        # Add an annotation inferred from the arguments; no dynamic axes here.
        in_type = tuple(unsafe_zip(abstract_args, itertools.repeat(True)))
        fun = lu.annotate(fun, in_type)
      else:
        assert abstract_args == (None,) * len(abstract_args)
        abstract_args = [aval for aval, _ in fun.in_type]
    
      with log_elapsed_time(f"Finished tracing + transforming {fun.__name__} "
                            "for jit in {elapsed_time} sec"):
>       jaxpr, out_type, consts = pe.trace_to_jaxpr_final2(
            fun, pe.debug_info_final(fun, "jit"))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lamb... at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True)))
kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
      with TraceAnnotation(name, **decorator_kwargs):
>       return func(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/profiler.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

debug_info = DebugInfo(func_src_info='<lambda> at /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/...e at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True))

    @profiler.annotate_function
    def trace_to_jaxpr_final2(
        fun: lu.WrappedFun, debug_info: Optional[DebugInfo] = None
      ) -> Tuple[Jaxpr, OutputType, List[Any]]:
      with core.new_base_main(DynamicJaxprTrace) as main:  # type: ignore
        main.jaxpr_stack = ()  # type: ignore
        with core.new_sublevel():
>         jaxpr, out_type, consts = trace_to_subjaxpr_dynamic2(fun, main, debug_info)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:2025: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

main = MainTrace(0,DynamicJaxprTrace)
debug_info = DebugInfo(func_src_info='<lambda> at /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/...e at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True))

    def trace_to_subjaxpr_dynamic2(
        fun: lu.WrappedFun, main: core.MainTrace,
        debug_info: Optional[DebugInfo] = None
    ) -> Tuple[Jaxpr, OutputType, List[Any]]:
      in_avals, keep_inputs = unzip2(fun.in_type)
      frame = JaxprStackFrame()
      frame.debug_info = debug_info
      with extend_jaxpr_stack(main, frame), source_info_util.reset_name_stack():
        trace = DynamicJaxprTrace(main, core.cur_sublevel())
        in_tracers = _input_type_to_tracers(trace.new_arg, in_avals)
        in_tracers_ = [t for t, keep in zip(in_tracers, keep_inputs) if keep]
>       ans = fun.call_wrapped(*in_tracers_)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
kwargs = {}, stack = [], gen = None, gen_static_args = None, out_store = None

    def call_wrapped(self, *args, **kwargs):
      """Calls the underlying function, applying the transforms.
    
      The positional `args` and keyword `kwargs` are passed to the first
      transformation generator.
      """
      stack = []
      for (gen, gen_static_args), out_store in zip(self.transforms, self.stores):
        gen = gen(*(gen_static_args + tuple(args)), **kwargs)
        args, kwargs = next(gen)
        stack.append((gen, out_store))
      gen = gen_static_args = out_store = None
    
      try:
>       ans = self.f(*args, **dict(self.params, **kwargs))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/linear_util.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x1 = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
x2 = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

>   fn = lambda x1, x2: lax_fn(*_promote_args(numpy_fn.__name__, x1, x2))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/ufuncs.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
y = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

    def eq(x: Array, y: Array) -> Array:
      r"""Elementwise equals: :math:`x = y`."""
>     return eq_p.bind(x, y)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/lax.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = eq
args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
params = {}

    def bind(self, *args, **params):
      assert (not config.jax_enable_checks or
              all(isinstance(arg, Tracer) or valid_jaxtype(arg) for arg in args)), args
>     return self.bind_with_trace(find_top_trace(args), args, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = eq, trace = DynamicJaxprTrace(level=0/1)
args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
params = {}

    def bind_with_trace(self, trace, args, params):
>     out = trace.process_primitive(self, map(trace.full_raise, args), params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DynamicJaxprTrace(level=0/1), primitive = eq
tracers = [Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>]
params = {}

    def process_primitive(self, primitive, tracers, params):
      if primitive in custom_staging_rules:
        return custom_staging_rules[primitive](self, *tracers, **params)
>     return self.default_process_primitive(primitive, tracers, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DynamicJaxprTrace(level=0/1), primitive = eq
tracers = [Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>]
params = {}

    def default_process_primitive(self, primitive, tracers, params):
      avals = [t.aval for t in tracers]
>     out_avals, effects = primitive.abstract_eval(*avals, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1662: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (ShapedArray(float64[3]), ShapedArray(float64[5])), kwargs = {}

    def abstract_eval_(*args, **kwargs):
>     return abstract_eval(*args, **kwargs), no_effects

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prim = eq
shape_rule = functools.partial(<function broadcasting_shape_rule at 0x7fa16b6f6c10>, 'eq')
dtype_rule = functools.partial(<function naryop_dtype_rule at 0x7fa16b6f6b80>, <function <lambda>.<locals>.<lambda> at 0x7fa16b71cc...>}, {<class 'numpy.complexfloating'>, <class 'numpy.floating'>, <class 'numpy.integer'>, <class 'numpy.bool_'>}], 'eq')
weak_type_rule = functools.partial(<function _naryop_weak_type_rule at 0x7fa16b6f6ca0>, 'eq')
named_shape_rule = <function standard_named_shape_rule at 0x7fa16b746f70>
avals = (ShapedArray(float64[3]), ShapedArray(float64[5])), kwargs = {}
weak_type = False, least_specialized = <class 'jax.core.ShapedArray'>

    def standard_abstract_eval(prim, shape_rule, dtype_rule, weak_type_rule,
                               named_shape_rule, *avals, **kwargs):
      assert all(isinstance(aval, core.UnshapedArray) for aval in avals), avals
      assert not prim.multiple_results
      weak_type = weak_type_rule(*avals, **kwargs)
      least_specialized = _max(map(type, avals),
                               key=operator.attrgetter('array_abstraction_level'))
      if least_specialized is core.ConcreteArray:
        out = prim.impl(*[x.val for x in avals], **kwargs)
        return core.ConcreteArray(out.dtype, out, weak_type=weak_type)
      elif least_specialized is core.ShapedArray:
>       return core.ShapedArray(shape_rule(*avals, **kwargs),
                                dtype_rule(*avals, **kwargs), weak_type=weak_type,

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/utils.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'eq', avals = (ShapedArray(float64[3]), ShapedArray(float64[5]))
shapes = [(3,), (5,)], result_shape = []

    def broadcasting_shape_rule(name, *avals):
      shapes = [aval.shape for aval in avals if aval.shape]
      if not shapes:
        return ()
      if len({len(shape) for shape in shapes}) != 1:
        msg = '{}: arrays must have same number of dimensions, got {}.'
        raise TypeError(msg.format(name, ', '.join(map(str, map(tuple, shapes)))))
      # TODO(mattjj): de-duplicate with _try_broadcast_shapes
      result_shape = []
      for ds in zip(*shapes):
        if all(core.same_referent(d, ds[0]) for d in ds[1:]):
          # if all axes are identical objects, the resulting size is the object
          result_shape.append(ds[0])
        else:
          # if all dims are equal (or 1), the result is the non-1 size
          non_1s = [d for d in ds if not core.symbolic_equal_dim(d, 1)]
          if not non_1s:
            result_shape.append(1)
          elif all(core.symbolic_equal_dim(non_1s[0], d) for d in non_1s[1:]):
            result_shape.append(non_1s[0])
          else:
>           raise TypeError(f'{name} got incompatible shapes for broadcasting: '
                            f'{", ".join(map(str, map(tuple, shapes)))}.')
E           jax._src.traceback_util.UnfilteredStackTrace: TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).
E           
E           The stack trace below excludes JAX-internal frames.
E           The preceding is the original exception that occurred, unmodified.
E           
E           --------------------

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/lax.py:1537: UnfilteredStackTrace

The above exception was the direct cause of the following exception:

kernel_fn = <class 'gpax.kernels.Matern32Kernel'>
kernel_params = {'lengthscale': None, 'variance': None}

    @pytest.mark.parametrize("kernel_fn", [RBFKernel, Matern12Kernel, Matern32Kernel, Matern52Kernel])
    @pytest.mark.parametrize(
        "kernel_params", [{"lengthscale": 0.5, "variance": 0.7}, {"lengthscale": None, "variance": None}]
    )
    def test_initialize(kernel_fn, kernel_params):
        kernel = kernel_fn(**kernel_params)
        key = jax.random.PRNGKey(0)
        X = jax.random.normal(key, (10, 2))
        params = kernel.initialise_params(key, X)
        ls = kernel_params["lengthscale"] if kernel_params["lengthscale"] is not None else [1.0, 1.0]
        var = kernel_params["variance"] if kernel_params["variance"] is not None else 1.0
        params_expected = {"kernel": {"lengthscale": jnp.array([ls, ls]), "variance": jnp.array(var)}}
        print(params)
        print(params_expected)
>       assert_same_pytree(params, params_expected)

tests/test_kernels.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/utils.py:8: in assert_same_pytree
    assert jnp.all(ravel_pytree(tree1)[0] == ravel_pytree(tree2)[0])
../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/lax_numpy.py:4658: in deferring_binary_op
    return binary_op(*args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x1 = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
x2 = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

>   fn = lambda x1, x2: lax_fn(*_promote_args(numpy_fn.__name__, x1, x2))
E   TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/ufuncs.py:72: TypeError
________________ test_initialize[kernel_params1-Matern52Kernel] ________________

    import re
    import sys
    from pytest import console_main
    if __name__ == '__main__':
        sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
>       sys.exit(console_main())

../miniconda3/envs/ajax/bin/pytest:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def console_main() -> int:
        """The CLI entry point of pytest.
    
        This function is not meant for programmable use; use `main()` instead.
        """
        # https://docs.python.org/3/library/signal.html#note-on-sigpipe
        try:
>           code = main()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/config/__init__.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = None, plugins = None

    def main(
        args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
        plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
    ) -> Union[int, ExitCode]:
        """Perform an in-process test run.
    
        :param args: List of command line arguments.
        :param plugins: List of plugin objects to be auto-registered during initialization.
    
        :returns: An exit code.
        """
        try:
            try:
                config = _prepareconfig(args, plugins)
            except ConftestImportFailure as e:
                exc_info = ExceptionInfo.from_exc_info(e.excinfo)
                tw = TerminalWriter(sys.stderr)
                tw.line(f"ImportError while loading conftest '{e.path}'.", red=True)
                exc_info.traceback = exc_info.traceback.filter(
                    filter_traceback_for_conftest_import_failure
                )
                exc_repr = (
                    exc_info.getrepr(style="short", chain=False)
                    if exc_info.traceback
                    else exc_info.exconly()
                )
                formatted_tb = str(exc_repr)
                for line in formatted_tb.splitlines():
                    tw.line(line.rstrip(), red=True)
                return ExitCode.USAGE_ERROR
            else:
                try:
>                   ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
                        config=config
                    )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/config/__init__.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_cmdline_main'>, args = ()
kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
argname = 'config', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_cmdline_main'
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...pytest.setuponly' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/setuponly.py'>>, ...]
kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_cmdline_main'
hook_impls = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...pytest.setuponly' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/setuponly.py'>>, ...]
caller_kwargs = {'config': <_pytest.config.Config object at 0x7fa20c94fd00>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>

    def pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:
>       return wrap_session(config, _main)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>
doit = <function _main at 0x7fa20cbb8670>

    def wrap_session(
        config: Config, doit: Callable[[Config, "Session"], Optional[Union[int, ExitCode]]]
    ) -> Union[int, ExitCode]:
        """Skeleton command line program."""
        session = Session.from_config(config)
        session.exitstatus = ExitCode.OK
        initstate = 0
        try:
            try:
                config._do_configure()
                initstate = 1
                config.hook.pytest_sessionstart(session=session)
                initstate = 2
>               session.exitstatus = doit(config, session) or 0

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7fa20c94fd00>
session = <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=3 testscollected=11>

    def _main(config: Config, session: "Session") -> Optional[Union[int, ExitCode]]:
        """Default command line protocol for initialization, session,
        running tests and reporting."""
        config.hook.pytest_collection(session=session)
>       config.hook.pytest_runtestloop(session=session)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtestloop'>, args = ()
kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=3 testscollected=11>}
argname = 'session', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtestloop'
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...t/main.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7fa20c7fa310>>]
kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=3 testscollected=11>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtestloop'
hook_impls = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9...t/main.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7fa20c7fa310>>]
caller_kwargs = {'session': <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=3 testscollected=11>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <Session gpax exitstatus=<ExitCode.OK: 0> testsfailed=3 testscollected=11>

    def pytest_runtestloop(session: "Session") -> bool:
        if session.testsfailed and not session.config.option.continue_on_collection_errors:
            raise session.Interrupted(
                "%d error%s during collection"
                % (session.testsfailed, "s" if session.testsfailed != 1 else "")
            )
    
        if session.config.option.collectonly:
            return True
    
        for i, item in enumerate(session.items):
            nextitem = session.items[i + 1] if i + 1 < len(session.items) else None
>           item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/main.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_protocol'>, args = ()
kwargs = {'item': <Function test_initialize[kernel_params1-Matern52Kernel]>, 'nextitem': <Function test_combinations>}
argname = 'nextitem', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtest_protocol'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...dule '_pytest.warnings' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/warnings.py'>>]
kwargs = {'item': <Function test_initialize[kernel_params1-Matern52Kernel]>, 'nextitem': <Function test_combinations>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_protocol'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...dule '_pytest.warnings' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/warnings.py'>>]
caller_kwargs = {'item': <Function test_initialize[kernel_params1-Matern52Kernel]>, 'nextitem': <Function test_combinations>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern52Kernel]>
nextitem = <Function test_combinations>

    def pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) -> bool:
        ihook = item.ihook
        ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)
>       runtestprotocol(item, nextitem=nextitem)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern52Kernel]>, log = True
nextitem = <Function test_combinations>

    def runtestprotocol(
        item: Item, log: bool = True, nextitem: Optional[Item] = None
    ) -> List[TestReport]:
        hasrequest = hasattr(item, "_request")
        if hasrequest and not item._request:  # type: ignore[attr-defined]
            # This only happens if the item is re-run, as is done by
            # pytest-rerunfailures.
            item._initrequest()  # type: ignore[attr-defined]
        rep = call_and_report(item, "setup", log)
        reports = [rep]
        if rep.passed:
            if item.config.getoption("setupshow", False):
                show_test_item(item)
            if not item.config.getoption("setuponly", False):
>               reports.append(call_and_report(item, "call", log))

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern52Kernel]>, when = 'call'
log = True, kwds = {}
call = <CallInfo when='call' excinfo=<ExceptionInfo TypeError('eq got incompatible shapes for broadcasting: (3,), (5,).') tblen=4>>
hook = <_pytest.config.compat.PathAwareHookProxy object at 0x7fa20c94fe80>

    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
>       call = call_runtest_hook(item, when, **kwds)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern52Kernel]>, when = 'call'
kwds = {}
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
>       return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7fa070367040>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_call'>, args = ()
kwargs = {'item': <Function test_initialize[kernel_params1-Matern52Kernel]>}
argname = 'item', firstresult = False

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...threadexception' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Function test_initialize[kernel_params1-Matern52Kernel]>}
firstresult = False

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/home/patel_zeel/miniconda3/envs/ajax/lib/pytho...threadexception' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Function test_initialize[kernel_params1-Matern52Kernel]>}
firstresult = False

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_initialize[kernel_params1-Matern52Kernel]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/runner.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Function test_initialize[kernel_params1-Matern52Kernel]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py:1761: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_pyfunc_call'>, args = ()
kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern52Kernel]>}
argname = 'pyfuncitem', firstresult = True

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
    
        # This is written to avoid expensive operations when not needed.
        if self.spec:
            for argname in self.spec.argnames:
                if argname not in kwargs:
                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())
                    warnings.warn(
                        "Argument(s) {} which are declared in the hookspec "
                        "can not be found in this hook call".format(notincall),
                        stacklevel=2,
                    )
                    break
    
            firstresult = self.spec.opts.get("firstresult")
        else:
            firstresult = False
    
>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_hooks.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7fa20c9aac40>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern52Kernel]>}
firstresult = True

    def _hookexec(self, hook_name, methods, kwargs, firstresult):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_manager.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_initialize[kernel_params1-Matern52Kernel]>}
firstresult = True

    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        """
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/pluggy/_callers.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pyfuncitem = <Function test_initialize[kernel_params1-Matern52Kernel]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: "Function") -> Optional[object]:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_warn_and_skip(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/_pytest/python.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

kernel_fn = <class 'gpax.kernels.Matern52Kernel'>
kernel_params = {'lengthscale': None, 'variance': None}

    @pytest.mark.parametrize("kernel_fn", [RBFKernel, Matern12Kernel, Matern32Kernel, Matern52Kernel])
    @pytest.mark.parametrize(
        "kernel_params", [{"lengthscale": 0.5, "variance": 0.7}, {"lengthscale": None, "variance": None}]
    )
    def test_initialize(kernel_fn, kernel_params):
        kernel = kernel_fn(**kernel_params)
        key = jax.random.PRNGKey(0)
        X = jax.random.normal(key, (10, 2))
        params = kernel.initialise_params(key, X)
        ls = kernel_params["lengthscale"] if kernel_params["lengthscale"] is not None else [1.0, 1.0]
        var = kernel_params["variance"] if kernel_params["variance"] is not None else 1.0
        params_expected = {"kernel": {"lengthscale": jnp.array([ls, ls]), "variance": jnp.array(var)}}
        print(params)
        print(params_expected)
>       assert_same_pytree(params, params_expected)

tests/test_kernels.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tree1 = {'kernel': {'lengthscale': DeviceArray([1., 1.], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}
tree2 = {'kernel': {'lengthscale': DeviceArray([[1., 1.],
             [1., 1.]], dtype=float64), 'variance': DeviceArray(1., dtype=float64, weak_type=True)}}

    def assert_same_pytree(tree1, tree2):
        assert tree_util.tree_structure(tree1) == tree_util.tree_structure(tree2)
>       assert jnp.all(ravel_pytree(tree1)[0] == ravel_pytree(tree2)[0])

tests/utils.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DeviceArray([1., 1., 1.], dtype=float64)
other = DeviceArray([1., 1., 1., 1., 1.], dtype=float64)

    def deferring_binary_op(self, other):
      if hasattr(other, '__jax_array__'):
        other = other.__jax_array__()
      args = (other, self) if swap else (self, other)
      if isinstance(other, _accepted_binop_types):
>       return binary_op(*args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/lax_numpy.py:4658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
kwargs = {}, __tracebackhide__ = True
msg = 'TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).\n\nThe stack trace below excludes JAX-internal frames.\nThe preceding is the original exception that occurred, unmodified.\n\n--------------------'

    @util.wraps(fun)
    def reraise_with_filtered_traceback(*args, **kwargs):
      __tracebackhide__ = True
      try:
>       return fun(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/traceback_util.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
kwargs = {}, closed_fun = Wrapped function:

Core: <lambda>

in_tree = PyTreeDef(((*, *), {}))
args_flat = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]
donated_invars = (False, False)
arg = DeviceArray([1., 1., 1., 1., 1.], dtype=float64)
flat_fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

out_tree = <function transformation_with_aux.<locals>.<lambda> at 0x7fa070367af0>

    @api_boundary
    def cache_miss(*args, **kwargs):
      ### This first part is basically the same code as in _python_jit.
      # An alternative would be for cache_miss to accept from C++ the arguments
      # (dyn_args, donated_invars, args_flat, in_tree), since otherwise we have
      # work/code that is redundant between C++ and Python. We can try that later.
      closed_fun, in_tree, args_flat, donated_invars = _prepare_jit(
          fun, static_argnums, static_argnames, donate_argnums, args, kwargs)
      for arg in args_flat:
        _check_arg(arg)
      flat_fun, out_tree = flatten_fun(closed_fun, in_tree)
      if jax.config.jax_dynamic_shapes:
        in_type = pe.infer_lambda_input_type(None, args_flat)
        flat_fun = lu.annotate(flat_fun, in_type)
>     out_flat = xla.xla_call(
          flat_fun, *args_flat,
          device=device, backend=backend, name=flat_fun.__name__,
          donated_invars=donated_invars, inline=inline, keep_unused=keep_unused)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/api.py:528: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = xla_call
fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}

    def bind(self, fun, *args, **params):
>     return call_bind(self, fun, *args, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

primitive = xla_call
fun = Wrapped function:
0   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64))
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}
top_trace = EvalTrace(level=0/0)
fun_ = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

env_trace_todo = <function transformation_with_aux.<locals>.<lambda> at 0x7fa02c5804c0>
tracers = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]

    def call_bind(primitive: CallPrimitive, fun, *args, **params):
      top_trace = find_top_trace(args)
      fun_, env_trace_todo = process_env_traces_call(
          fun, primitive, top_trace and top_trace.level, tuple(params.items()))
      tracers = map(top_trace.full_raise, args)
      fun_ = lu.annotate(fun_, fun.in_type)
>     outs = top_trace.process_call(primitive, fun_, tracers, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:1979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = EvalTrace(level=0/0), primitive = xla_call
f = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

tracers = [DeviceArray([1., 1., 1.], dtype=float64), DeviceArray([1., 1., 1., 1., 1.], dtype=float64)]
params = {'backend': None, 'device': None, 'donated_invars': (False, False), 'inline': True, ...}

    def process_call(self, primitive, f, tracers, params):
>     return primitive.impl(f, *tracers, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:689: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False)

    def _xla_call_impl(fun: lu.WrappedFun, *args, device, backend, name,
                       donated_invars, inline, keep_unused: bool):
      del inline  # Only used at tracing time
      if fun.in_type is None:
        arg_specs = unsafe_map(arg_spec, args)
      else:
        # fun.in_type is used for dynamic shapes.
        if config.jax_array:
          raise NotImplementedError('Dynamic shapes do not work with Array.')
        arg_specs = [(None, getattr(x, '_device', None)) for x in args]
>     compiled_fun = xla_callable(fun, device, backend, name, donated_invars,
                                  keep_unused, *arg_specs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (None, None, '<lambda>', (False, False), False, (ShapedArray(float64[3]), None), ...)
cache = {(((<function process_env_traces_call at 0x7fa0be9c6e50>, (xla_call, 0, ((...), (...), (...), (...), (...), (...)))), ... {0, 1}, False), (<jax.linear_util.Store object at 0x7fa07816c580>, <jax.linear_util.Store object at 0x7fa07816c0d0>))}
key = (((<function process_env_traces_call at 0x7fa0be9c6e50>, (xla_call, 0, (('device', None), ('backend', None), ('name', ...,))), (), None, (None, None, '<lambda>', (False, False), False, (ShapedArray(float64[3]), None), ...), True, None, ...)
result = None

    def memoized_fun(fun: WrappedFun, *args):
      cache = fun_caches.setdefault(fun.f, {})
      if config.jax_check_tracer_leaks:
        key = (_copy_main_traces(fun.transforms), fun.params, fun.in_type, args,
               config.x64_enabled, config.jax_default_device,
               config._trace_context())
      else:
        key = (fun.transforms, fun.params, fun.in_type, args, config.x64_enabled,
               config.jax_default_device, config._trace_context())
      result = cache.get(key, None)
      if result is not None:
        ans, stores = result
        fun.populate_stores(stores)
      else:
>       ans = call(fun, *args)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/linear_util.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False), keep_unused = False
arg_specs = ((ShapedArray(float64[3]), None), (ShapedArray(float64[5]), None))

    def _xla_callable_uncached(fun: lu.WrappedFun, device, backend, name,
                               donated_invars, keep_unused, *arg_specs):
      # TODO(yashkatariya): Remove the `and arg_specs` from here once
      # lower_sharding_computation supports no avals as input.
      if config.jax_array and arg_specs:
        return sharded_lowering(fun, device, backend, name,
                                donated_invars, keep_unused, *arg_specs)
      else:
>       return lower_xla_callable(fun, device, backend, name, donated_invars, False,
                                  keep_unused, *arg_specs).compile().unsafe_call

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lamb...)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>
, None, None, '<lambda>', (False, False), False, ...)
kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
      with TraceAnnotation(name, **decorator_kwargs):
>       return func(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/profiler.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

device = None, backend = None, name = '<lambda>'
donated_invars = (False, False), always_lower = False, keep_unused = False
arg_specs = ((ShapedArray(float64[3]), None), (ShapedArray(float64[5]), None))
abstract_args = (ShapedArray(float64[3]), ShapedArray(float64[5]))
arg_devices = (None, None)
in_type = ((ShapedArray(float64[3]), True), (ShapedArray(float64[5]), True))

    @profiler.annotate_function
    def lower_xla_callable(
        fun: lu.WrappedFun, device, backend, name, donated_invars,
        always_lower: bool, keep_unused: bool, *arg_specs):
      """Lower into XLA.
    
      Args:
        always_lower: If `True`, even trivial programs (not doing any computation
          such as lambda x: x) will be lowered into an XLA program.
        keep_unused: If `False` (the default), arguments that JAX determines to be
          unused by `fun` *may* be dropped from resulting compiled XLA executables.
          Such arguments will not be transferred to the device nor provided to the
          underlying executable. If `True`, unused arguments will not be pruned.
      """
      if device is not None and backend is not None:
        raise ValueError("can't specify both a device and a backend for jit, "
                         "got device={} and backend={}".format(device, backend))
      abstract_args, arg_devices = util.unzip2(arg_specs)
      if fun.in_type is None:
        # Add an annotation inferred from the arguments; no dynamic axes here.
        in_type = tuple(unsafe_zip(abstract_args, itertools.repeat(True)))
        fun = lu.annotate(fun, in_type)
      else:
        assert abstract_args == (None,) * len(abstract_args)
        abstract_args = [aval for aval, _ in fun.in_type]
    
      with log_elapsed_time(f"Finished tracing + transforming {fun.__name__} "
                            "for jit in {elapsed_time} sec"):
>       jaxpr, out_type, consts = pe.trace_to_jaxpr_final2(
            fun, pe.debug_info_final(fun, "jit"))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/dispatch.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lamb... at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True)))
kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
      with TraceAnnotation(name, **decorator_kwargs):
>       return func(*args, **kwargs)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/profiler.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

debug_info = DebugInfo(func_src_info='<lambda> at /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/...e at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True))

    @profiler.annotate_function
    def trace_to_jaxpr_final2(
        fun: lu.WrappedFun, debug_info: Optional[DebugInfo] = None
      ) -> Tuple[Jaxpr, OutputType, List[Any]]:
      with core.new_base_main(DynamicJaxprTrace) as main:  # type: ignore
        main.jaxpr_stack = ()  # type: ignore
        with core.new_sublevel():
>         jaxpr, out_type, consts = trace_to_subjaxpr_dynamic2(fun, main, debug_info)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:2025: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

main = MainTrace(0,DynamicJaxprTrace)
debug_info = DebugInfo(func_src_info='<lambda> at /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/...e at 0x7fa0be80e700>, <function _one_to_one_binop.<locals>.<lambda> at 0x7fa0be22a790>, PyTreeDef(((*, *), {})), True))

    def trace_to_subjaxpr_dynamic2(
        fun: lu.WrappedFun, main: core.MainTrace,
        debug_info: Optional[DebugInfo] = None
    ) -> Tuple[Jaxpr, OutputType, List[Any]]:
      in_avals, keep_inputs = unzip2(fun.in_type)
      frame = JaxprStackFrame()
      frame.debug_info = debug_info
      with extend_jaxpr_stack(main, frame), source_info_util.reset_name_stack():
        trace = DynamicJaxprTrace(main, core.cur_sublevel())
        in_tracers = _input_type_to_tracers(trace.new_arg, in_avals)
        in_tracers_ = [t for t, keep in zip(in_tracers, keep_inputs) if keep]
>       ans = fun.call_wrapped(*in_tracers_)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Wrapped function:
0   : process_env_traces_call   (xla_call, 0, (('device', None), ('backend', None), ('name', '<lambd...lse, False)), ('inline', True), ('keep_unused', False)))
1   : flatten_fun   (PyTreeDef(((*, *), {})),)
Core: <lambda>

args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
kwargs = {}, stack = [], gen = None, gen_static_args = None, out_store = None

    def call_wrapped(self, *args, **kwargs):
      """Calls the underlying function, applying the transforms.
    
      The positional `args` and keyword `kwargs` are passed to the first
      transformation generator.
      """
      stack = []
      for (gen, gen_static_args), out_store in zip(self.transforms, self.stores):
        gen = gen(*(gen_static_args + tuple(args)), **kwargs)
        args, kwargs = next(gen)
        stack.append((gen, out_store))
      gen = gen_static_args = out_store = None
    
      try:
>       ans = self.f(*args, **dict(self.params, **kwargs))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/linear_util.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x1 = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
x2 = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

>   fn = lambda x1, x2: lax_fn(*_promote_args(numpy_fn.__name__, x1, x2))

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/ufuncs.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
y = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

    def eq(x: Array, y: Array) -> Array:
      r"""Elementwise equals: :math:`x = y`."""
>     return eq_p.bind(x, y)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/lax.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = eq
args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
params = {}

    def bind(self, *args, **params):
      assert (not config.jax_enable_checks or
              all(isinstance(arg, Tracer) or valid_jaxtype(arg) for arg in args)), args
>     return self.bind_with_trace(find_top_trace(args), args, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = eq, trace = DynamicJaxprTrace(level=0/1)
args = (Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>)
params = {}

    def bind_with_trace(self, trace, args, params):
>     out = trace.process_primitive(self, map(trace.full_raise, args), params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DynamicJaxprTrace(level=0/1), primitive = eq
tracers = [Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>]
params = {}

    def process_primitive(self, primitive, tracers, params):
      if primitive in custom_staging_rules:
        return custom_staging_rules[primitive](self, *tracers, **params)
>     return self.default_process_primitive(primitive, tracers, params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1658: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = DynamicJaxprTrace(level=0/1), primitive = eq
tracers = [Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>, Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>]
params = {}

    def default_process_primitive(self, primitive, tracers, params):
      avals = [t.aval for t in tracers]
>     out_avals, effects = primitive.abstract_eval(*avals, **params)

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/interpreters/partial_eval.py:1662: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (ShapedArray(float64[3]), ShapedArray(float64[5])), kwargs = {}

    def abstract_eval_(*args, **kwargs):
>     return abstract_eval(*args, **kwargs), no_effects

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/core.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prim = eq
shape_rule = functools.partial(<function broadcasting_shape_rule at 0x7fa16b6f6c10>, 'eq')
dtype_rule = functools.partial(<function naryop_dtype_rule at 0x7fa16b6f6b80>, <function <lambda>.<locals>.<lambda> at 0x7fa16b71cc...>}, {<class 'numpy.complexfloating'>, <class 'numpy.floating'>, <class 'numpy.integer'>, <class 'numpy.bool_'>}], 'eq')
weak_type_rule = functools.partial(<function _naryop_weak_type_rule at 0x7fa16b6f6ca0>, 'eq')
named_shape_rule = <function standard_named_shape_rule at 0x7fa16b746f70>
avals = (ShapedArray(float64[3]), ShapedArray(float64[5])), kwargs = {}
weak_type = False, least_specialized = <class 'jax.core.ShapedArray'>

    def standard_abstract_eval(prim, shape_rule, dtype_rule, weak_type_rule,
                               named_shape_rule, *avals, **kwargs):
      assert all(isinstance(aval, core.UnshapedArray) for aval in avals), avals
      assert not prim.multiple_results
      weak_type = weak_type_rule(*avals, **kwargs)
      least_specialized = _max(map(type, avals),
                               key=operator.attrgetter('array_abstraction_level'))
      if least_specialized is core.ConcreteArray:
        out = prim.impl(*[x.val for x in avals], **kwargs)
        return core.ConcreteArray(out.dtype, out, weak_type=weak_type)
      elif least_specialized is core.ShapedArray:
>       return core.ShapedArray(shape_rule(*avals, **kwargs),
                                dtype_rule(*avals, **kwargs), weak_type=weak_type,

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/utils.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'eq', avals = (ShapedArray(float64[3]), ShapedArray(float64[5]))
shapes = [(3,), (5,)], result_shape = []

    def broadcasting_shape_rule(name, *avals):
      shapes = [aval.shape for aval in avals if aval.shape]
      if not shapes:
        return ()
      if len({len(shape) for shape in shapes}) != 1:
        msg = '{}: arrays must have same number of dimensions, got {}.'
        raise TypeError(msg.format(name, ', '.join(map(str, map(tuple, shapes)))))
      # TODO(mattjj): de-duplicate with _try_broadcast_shapes
      result_shape = []
      for ds in zip(*shapes):
        if all(core.same_referent(d, ds[0]) for d in ds[1:]):
          # if all axes are identical objects, the resulting size is the object
          result_shape.append(ds[0])
        else:
          # if all dims are equal (or 1), the result is the non-1 size
          non_1s = [d for d in ds if not core.symbolic_equal_dim(d, 1)]
          if not non_1s:
            result_shape.append(1)
          elif all(core.symbolic_equal_dim(non_1s[0], d) for d in non_1s[1:]):
            result_shape.append(non_1s[0])
          else:
>           raise TypeError(f'{name} got incompatible shapes for broadcasting: '
                            f'{", ".join(map(str, map(tuple, shapes)))}.')
E           jax._src.traceback_util.UnfilteredStackTrace: TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).
E           
E           The stack trace below excludes JAX-internal frames.
E           The preceding is the original exception that occurred, unmodified.
E           
E           --------------------

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/lax/lax.py:1537: UnfilteredStackTrace

The above exception was the direct cause of the following exception:

kernel_fn = <class 'gpax.kernels.Matern52Kernel'>
kernel_params = {'lengthscale': None, 'variance': None}

    @pytest.mark.parametrize("kernel_fn", [RBFKernel, Matern12Kernel, Matern32Kernel, Matern52Kernel])
    @pytest.mark.parametrize(
        "kernel_params", [{"lengthscale": 0.5, "variance": 0.7}, {"lengthscale": None, "variance": None}]
    )
    def test_initialize(kernel_fn, kernel_params):
        kernel = kernel_fn(**kernel_params)
        key = jax.random.PRNGKey(0)
        X = jax.random.normal(key, (10, 2))
        params = kernel.initialise_params(key, X)
        ls = kernel_params["lengthscale"] if kernel_params["lengthscale"] is not None else [1.0, 1.0]
        var = kernel_params["variance"] if kernel_params["variance"] is not None else 1.0
        params_expected = {"kernel": {"lengthscale": jnp.array([ls, ls]), "variance": jnp.array(var)}}
        print(params)
        print(params_expected)
>       assert_same_pytree(params, params_expected)

tests/test_kernels.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/utils.py:8: in assert_same_pytree
    assert jnp.all(ravel_pytree(tree1)[0] == ravel_pytree(tree2)[0])
../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/lax_numpy.py:4658: in deferring_binary_op
    return binary_op(*args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x1 = Traced<ShapedArray(float64[3])>with<DynamicJaxprTrace(level=0/1)>
x2 = Traced<ShapedArray(float64[5])>with<DynamicJaxprTrace(level=0/1)>

>   fn = lambda x1, x2: lax_fn(*_promote_args(numpy_fn.__name__, x1, x2))
E   TypeError: eq got incompatible shapes for broadcasting: (3,), (5,).

../miniconda3/envs/ajax/lib/python3.9/site-packages/jax/_src/numpy/ufuncs.py:72: TypeError
=============================== warnings summary ===============================
../miniconda3/envs/ajax/lib/python3.9/site-packages/flatbuffers/compat.py:19
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/flatbuffers/compat.py:19: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
    import imp

../miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:36
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:36: DeprecationWarning: NEAREST is deprecated and will be removed in Pillow 10 (2023-07-01). Use Resampling.NEAREST or Dither.NONE instead.
    'nearest': pil_image.NEAREST,

../miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:37
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:37: DeprecationWarning: BILINEAR is deprecated and will be removed in Pillow 10 (2023-07-01). Use Resampling.BILINEAR instead.
    'bilinear': pil_image.BILINEAR,

../miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:38
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:38: DeprecationWarning: BICUBIC is deprecated and will be removed in Pillow 10 (2023-07-01). Use Resampling.BICUBIC instead.
    'bicubic': pil_image.BICUBIC,

../miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:39
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:39: DeprecationWarning: HAMMING is deprecated and will be removed in Pillow 10 (2023-07-01). Use Resampling.HAMMING instead.
    'hamming': pil_image.HAMMING,

../miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:40
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:40: DeprecationWarning: BOX is deprecated and will be removed in Pillow 10 (2023-07-01). Use Resampling.BOX instead.
    'box': pil_image.BOX,

../miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:41
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/keras/utils/image_utils.py:41: DeprecationWarning: LANCZOS is deprecated and will be removed in Pillow 10 (2023-07-01). Use Resampling.LANCZOS instead.
    'lanczos': pil_image.LANCZOS,

tests/test_kernels.py::test_combinations
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/plum/function.py:592: ToDenseWarning: Multiplying <dense matrix: batch=(), shape=(10, 10), dtype=float64> and <low-rank matrix: batch=(), shape=(10, 10), dtype=float64, rank=1>: converting to dense.
    return _convert(method(*args, **kw_args), return_type)

tests/test_kernels.py::test_combinations
  /home/patel_zeel/miniconda3/envs/ajax/lib/python3.9/site-packages/plum/function.py:584: ToDenseWarning: Multiplying <dense matrix: batch=(), shape=(10, 10), dtype=float64> and <low-rank matrix: batch=(), shape=(10, 10), dtype=float64, rank=1>: converting to dense.
    return method(*args, **kw_args)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_kernels.py::test_initialize[kernel_params1-RBFKernel] - Typ...
FAILED tests/test_kernels.py::test_initialize[kernel_params1-Matern12Kernel]
FAILED tests/test_kernels.py::test_initialize[kernel_params1-Matern32Kernel]
FAILED tests/test_kernels.py::test_initialize[kernel_params1-Matern52Kernel]
=================== 4 failed, 7 passed, 9 warnings in 16.72s ===================
